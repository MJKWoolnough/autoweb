const e=e=>e instanceof Array&&2===e.length&&e[0]instanceof n,t=e=>e instanceof Array&&2===e.length&&e[0]instanceof s;class n{#e=[];get length(){return this.#e.length}send(e){for(const t of this.#e)try{t(e)}finally{}}receive(e){this.#e.push(e)}remove(e){for(const[t,n]of this.#e.entries())if(n===e)return this.#e.splice(t,1),!0;return!1}bind(e=7){return[1&e?e=>this.send(e):void 0,2&e?e=>this.receive(e):void 0,4&e?e=>this.remove(e):void 0]}static any(t,...s){let o=!1;const r=s.map((t=>t instanceof n?void 0:e(t)?t[1]:t)),c=[];for(const[i,a]of s.entries())if(a instanceof n||e(a)){const e=a instanceof Array?a[0]:a,n=e=>{r[i]=e,o||(o=!0,queueMicrotask((()=>{t(r),o=!1})))};e.receive(n),c.push((()=>e.remove(n)))}return()=>{for(const e of c)e()}}}class s{#t;#n;#s;#o;constructor(e){const[t,s]=(new n).bind(3),o=new n,[,r]=o.bind(2);e(t,(e=>{if(!o.length)throw e;o.send(e)}),(e=>this.#s=e)),this.#t=s,this.#n=r}when(e,t){const n=new s(((n,s)=>{this.#t(e instanceof Function?t=>{try{n(e(t))}catch(e){s(e)}}:n),this.#n(t instanceof Function?e=>{try{n(t(e))}catch(e){s(e)}}:s)}));return n.#o=n.#s=this.#o??=()=>this.#s?.(),n}cancel(){this.#s?.()}catch(e){return this.when(void 0,e)}finally(e){return this.when((t=>(e(),t)),(t=>{throw e(),t}))}splitCancel(e=!1){const[t,o,r]=(new n).bind(),[c,i,a]=(new n).bind();let d=0;return this.when(t,c),()=>new s(((t,n,s)=>{d++,o(t),i(n),s((()=>{r(t),a(n),s((()=>{})),! --d&&e&&this.cancel()}))}))}static merge(...e){return new s(((t,n,s)=>{for(const s of e)s.when(t,n);s((()=>{for(const t of e)t.cancel()}))}))}static any(...e){let n=!1;const[o,r,c,i]=s.bind(),a=e.map((e=>e instanceof s?void 0:t(e)?e[1]:e));for(const[o,i]of e.entries())(i instanceof s||t(i))&&(i instanceof Array?i[0]:i).when((e=>{a[o]=e,n||(n=!0,queueMicrotask((()=>{r(a),n=!1})))}),c);return i((()=>{for(const n of e)(n instanceof s||t(n))&&(n instanceof Array?n[0]:n).cancel()})),o}static bind(e=7){let t,n,o;return[new s(((e,s,r)=>{t=e,n=s,o=r})),1&e?t:void 0,2&e?n:void 0,4&e?o:void 0]}}const o={once:!0},r=new URL(window.location+""),c=XMLHttpRequest;class i extends WebSocket{constructor(e,t){super(new URL(e,r),t)}when(e,t){return new s(((e,t,n)=>{const s=this,o=new AbortController,r={signal:o.signal};s.addEventListener("message",e,r),s.addEventListener("error",(e=>t(e.error)),r),s.addEventListener("close",(e=>{const n=new Error(e.reason);n.name="CloseError",t(n),o.abort()}),r),n((()=>o.abort()))})).when(e,t)}}r.protocol="https"===r.protocol?"wss":"ws";const a="complete"===document.readyState?Promise.resolve():new Promise((e=>window.addEventListener("load",e,{once:!0}))),d=(()=>{let e=Promise.resolve();return t=>e=e.finally(t)})();new Intl.Collator;const l=()=>{},h=[l,l],u=(e,t)=>{const n=new Set;return e.set(t,n),n},w=(e,t,n)=>[s=>{try{!n||n(s)?e(s):t(new TypeError("invalid type"))}catch(e){t(e)}},t];class f{code;message;data;constructor(e,t,n){this.code=e,this.message=t,this.data=n,Object.freeze(this)}get name(){return"RPCError"}toString(){return this.message}}class p extends Array{#r;constructor(e){super(),this.#r=e}close(){for(const e of this)this.#r(e)}send(e){this.push(e)}when(){}}d((()=>a));const m=fetch,y=new class{#c;#i=0;#a=new Map;#d=new Map;#l;#h;constructor(e){this.#u(e)}#u(e){(this.#c=e??new p((e=>this.#c?.send(e)))).when(this.#l??=({data:e})=>{const t=JSON.parse(e),n="string"==typeof t.id?parseInt(t.id):t.id,s=t.error,o=+!!s,r=s?new f(s.code,s.message,s.data):t.result;if(n>=0)(this.#a.get(n)??h)[o](r),this.#a.delete(n);else for(const e of this.#d.get(n)??[])e[o](r)},this.#h??=e=>{this.close();for(const[,t]of this.#a)t[1](e);for(const[,t]of this.#d)for(const n of t)n[1](e)})}reconnect(e){const t=this.#c;this.#u(e),t?.close()}request(e,t,n){const s=this.#c;return s?new Promise(((o,r)=>{n??=t instanceof Function?t:void 0;const c=this.#i++;this.#a.set(c,w(o,r,n)),s.send(JSON.stringify({id:c,method:e,params:t instanceof Function?void 0:t}))})):Promise.reject("RPC Closed")}await(e,t){const n=[l,l],s=this.#d,o=s.get(e)??u(s,e),r=new Promise(((e,s)=>{[n[0],n[1]]=w(e,s,t),o.add(n)}));return r.finally((()=>o.delete(n))).catch((()=>{})),r}subscribe(e,t){return new s(((n,s,o)=>{const r=w(n,s,t),c=this.#d,i=c.get(e)??u(c,e);i.add(r),o((()=>i.delete(r)))}))}close(){const e=this.#c;this.#c=null,e?.close()}},v=Array.from(document.documentElement.children),g=e=>"centre"===e||"middle"===e?"center":e??"left",b=e=>((e,t={})=>new Promise(((n,s)=>{const r=new c;if(r.open(t.method??"GET",e),t.hasOwnProperty("headers")&&"object"==typeof t.headers)for(const[e,n]of Object.entries(t.headers))r.setRequestHeader(e,n);switch(void 0!==t.type&&r.setRequestHeader("Content-Type",t.type),(t.user||t.password)&&r.setRequestHeader("Authorization","Basic "+btoa(`${t.user??""}:${t.password??""}`)),r.addEventListener("readystatechange",(()=>{4===r.readyState&&(r.status>=200&&r.status<300?"json"===t.response&&t.checker&&!t.checker(r.response)?s(new TypeError("received JSON does not match expected format")):n("xh"===t.response?r:r.response):s(new Error(r.response)))})),t.onuploadprogress&&r.upload.addEventListener("progress",t.onuploadprogress),t.ondownloadprogress&&r.addEventListener("progress",t.ondownloadprogress),t.response){case"text":r.overrideMimeType("text/plain");break;case"xml":r.overrideMimeType("text/xml"),r.responseType="document";break;case"json":r.overrideMimeType("application/json");case"document":case"blob":case"arraybuffer":r.responseType=t.response}if(t.signal){const e=t.signal;e.addEventListener("abort",(()=>{r.abort(),s(e.reason instanceof Error?e.reason:new Error(e.reason))}),o)}r.send(t.data??null)})))(e,{headers:{"Cache-Control":"no-cache, no-store, max-age=0"}}).then((t=>{history.pushState(+new Date,"",new URL(e,window.location+"")),document.documentElement.innerHTML=t})),E=Object.freeze({load:b,moveMouse:(e,t)=>d((()=>y.request("moveMouse",[0+e|0,0+t|0]))),clickMouse:e=>d((()=>y.request("clickMouse",g(e)))),dblClickMouse:e=>d((()=>y.request("dblClickMouse",g(e)))),mouseDown:e=>d((()=>y.request("mouseDown",g(e)))),mouseUp:e=>d((()=>y.request("mouseUp",g(e)))),keyPress:e=>d((()=>y.request("keyPress",e))),keyDown:e=>d((()=>y.request("keyDown",e))),keyUp:e=>d((()=>y.request("keyUp",e)))});window.WebSocket=class extends WebSocket{},window.XMLHttpRequest=class extends XMLHttpRequest{},window.fetch=(e,t)=>m(e,t),window.addEventListener("click",(e=>{let t=e.target;for(;t&&!(t instanceof HTMLAnchorElement||t instanceof HTMLAreaElement||t instanceof SVGAElement);)t=t.parentNode;const n=t?.getAttribute("href"),s=n?new URL(n,window.location+""):null;s?.host===window.location.host&&(b(n??""),e.preventDefault())}));export default(e,t)=>d((()=>new Promise(((e,t)=>{const n=new i("/socket");n.addEventListener("open",(()=>{n.removeEventListener("error",t),e(n)}),o),n.addEventListener("error",t,o)})).then((n=>(y.reconnect(n),y.request("proxy",e).then((()=>t(E))).catch((e=>console.log(e))).finally((()=>{y?.close(),history.pushState(+new Date,"",new URL("/",window.location+"")),document.documentElement.replaceChildren(...v)})))))));