const e=e=>e instanceof Array&&2===e.length&&e[0]instanceof s,t=e=>e instanceof Array&&2===e.length&&e[0]instanceof n;class s{#e=[];get length(){return this.#e.length}send(e){for(const t of this.#e)try{t(e)}finally{}}receive(e){this.#e.push(e)}remove(e){for(const[t,s]of this.#e.entries())if(s===e)return this.#e.splice(t,1),!0;return!1}bind(e=7){return[1&e?e=>this.send(e):void 0,2&e?e=>this.receive(e):void 0,4&e?e=>this.remove(e):void 0]}static any(t,...n){let o=!1;const r=n.map((t=>t instanceof s?void 0:e(t)?t[1]:t)),c=[];for(const[i,a]of n.entries())if(a instanceof s||e(a)){const e=a instanceof Array?a[0]:a,s=e=>{r[i]=e,o||(o=!0,queueMicrotask((()=>{t(r),o=!1})))};e.receive(s),c.push((()=>e.remove(s)))}return()=>{for(const e of c)e()}}}class n{#t;#s;#n;#o;constructor(e){const[t,n]=(new s).bind(3),o=new s,[,r]=o.bind(2);e(t,(e=>{if(!o.length)throw e;o.send(e)}),(e=>this.#n=e)),this.#t=n,this.#s=r}when(e,t){const s=new n(((s,n)=>{this.#t(e instanceof Function?t=>{try{s(e(t))}catch(e){n(e)}}:s),this.#s(t instanceof Function?e=>{try{s(t(e))}catch(e){n(e)}}:n)}));return s.#o=s.#n=this.#o??=()=>this.#n?.(),s}cancel(){this.#n?.()}catch(e){return this.when(void 0,e)}finally(e){return this.when((t=>(e(),t)),(t=>{throw e(),t}))}splitCancel(e=!1){const[t,o,r]=(new s).bind(),[c,i,a]=(new s).bind();let d=0;return this.when(t,c),()=>new n(((t,s,n)=>{d++,o(t),i(s),n((()=>{r(t),a(s),n((()=>{})),! --d&&e&&this.cancel()}))}))}static merge(...e){return new n(((t,s,n)=>{for(const n of e)n.when(t,s);n((()=>{for(const t of e)t.cancel()}))}))}static any(...e){let s=!1;const[o,r,c,i]=n.bind(),a=e.map((e=>e instanceof n?void 0:t(e)?e[1]:e));for(const[o,i]of e.entries())(i instanceof n||t(i))&&(i instanceof Array?i[0]:i).when((e=>{a[o]=e,s||(s=!0,queueMicrotask((()=>{r(a),s=!1})))}),c);return i((()=>{for(const s of e)(s instanceof n||t(s))&&(s instanceof Array?s[0]:s).cancel()})),o}static bind(e=7){let t,s,o;return[new n(((e,n,r)=>{t=e,s=n,o=r})),1&e?t:void 0,2&e?s:void 0,4&e?o:void 0]}}const o={once:!0},r=new URL(window.location+""),c=XMLHttpRequest;class i extends WebSocket{constructor(e,t){super(new URL(e,r),t)}when(e,t){return new n(((e,t,s)=>{const n=this,o=new AbortController,r={signal:o.signal};n.addEventListener("message",e,r),n.addEventListener("error",(e=>t(e.error)),r),n.addEventListener("close",(e=>{const s=new Error(e.reason);s.name="CloseError",t(s),o.abort()}),r),s((()=>o.abort()))})).when(e,t)}}r.protocol="https"===r.protocol?"wss":"ws";const a="complete"===document.readyState?Promise.resolve():new Promise((e=>window.addEventListener("load",e,{once:!0}))),d=(()=>{let e=Promise.resolve();return t=>e=e.finally(t)})();new Intl.Collator;const l=()=>{},h=[l,l],u=(e,t)=>{const s=new Set;return e.set(t,s),s},f=(e,t,s)=>[n=>{try{!s||s(n)?e(n):t(new TypeError("invalid type"))}catch(e){t(e)}},t];class p{code;message;data;constructor(e,t,s){this.code=e,this.message=t,this.data=s,Object.freeze(this)}get name(){return"RPCError"}toString(){return this.message}}class w extends Array{#r;constructor(e){super(),this.#r=e}close(){for(const e of this)this.#r(e)}send(e){this.push(e)}when(){}}d((()=>a));const m=fetch,y=new class{#c;#i=0;#a=new Map;#d=new Map;#l;#h;constructor(e){this.#u(e)}#u(e){(this.#c=e??new w((e=>this.#c?.send(e)))).when(this.#l??=({data:e})=>{const t=JSON.parse(e),s="string"==typeof t.id?parseInt(t.id):t.id,n=t.error,o=+!!n,r=n?new p(n.code,n.message,n.data):t.result;if(s>=0)(this.#a.get(s)??h)[o](r),this.#a.delete(s);else for(const e of this.#d.get(s)??[])e[o](r)},this.#h??=e=>{this.close();for(const[,t]of this.#a)t[1](e);for(const[,t]of this.#d)for(const s of t)s[1](e)})}reconnect(e){const t=this.#c;this.#u(e),t?.close()}request(e,t,s){const n=this.#c;return n?new Promise(((o,r)=>{s??=t instanceof Function?t:void 0;const c=this.#i++;this.#a.set(c,f(o,r,s)),n.send(JSON.stringify({id:c,method:e,params:t instanceof Function?void 0:t}))})):Promise.reject("RPC Closed")}await(e,t){const s=[l,l],n=this.#d,o=n.get(e)??u(n,e),r=new Promise(((e,n)=>{[s[0],s[1]]=f(e,n,t),o.add(s)}));return r.finally((()=>o.delete(s))).catch((()=>{})),r}subscribe(e,t){return new n(((s,n,o)=>{const r=f(s,n,t),c=this.#d,i=c.get(e)??u(c,e);i.add(r),o((()=>i.delete(r)))}))}close(){const e=this.#c;this.#c=null,e?.close()}},v=e=>"centre"===e||"middle"===e?"center":e??"left",g=Object.freeze({load:e=>((e,t={})=>new Promise(((s,n)=>{const r=new c;if(r.open(t.method??"GET",e),t.hasOwnProperty("headers")&&"object"==typeof t.headers)for(const[e,s]of Object.entries(t.headers))r.setRequestHeader(e,s);switch(void 0!==t.type&&r.setRequestHeader("Content-Type",t.type),(t.user||t.password)&&r.setRequestHeader("Authorization","Basic "+btoa(`${t.user??""}:${t.password??""}`)),r.addEventListener("readystatechange",(()=>{4===r.readyState&&(r.status>=200&&r.status<300?"json"===t.response&&t.checker&&!t.checker(r.response)?n(new TypeError("received JSON does not match expected format")):s("xh"===t.response?r:r.response):n(new Error(r.response)))})),t.onuploadprogress&&r.upload.addEventListener("progress",t.onuploadprogress),t.ondownloadprogress&&r.addEventListener("progress",t.ondownloadprogress),t.response){case"text":r.overrideMimeType("text/plain");break;case"xml":r.overrideMimeType("text/xml"),r.responseType="document";break;case"json":r.overrideMimeType("application/json");case"document":case"blob":case"arraybuffer":r.responseType=t.response}if(t.signal){const e=t.signal;e.addEventListener("abort",(()=>{r.abort(),n(e.reason instanceof Error?e.reason:new Error(e.reason))}),o)}r.send(t.data??null)})))(e).then((e=>{document.documentElement.innerHTML=e})),moveMouse:(e,t)=>d((()=>y.request("moveMouse",[0+e|0,0+t|0]))),clickMouse:e=>d((()=>y.request("clickMouse",v(e)))),dblClickMouse:e=>d((()=>y.request("dblClickMouse",v(e)))),mouseDown:e=>d((()=>y.request("mouseDown",v(e)))),mouseUp:e=>d((()=>y.request("mouseUp",v(e)))),keyPress:e=>d((()=>y.request("keyPress",e))),keyDown:e=>d((()=>y.request("keyDown",e))),keyUp:e=>d((()=>y.request("keyUp",e)))});window.WebSocket=class extends WebSocket{},window.XMLHttpRequest=class extends XMLHttpRequest{},window.fetch=(e,t)=>m(e,t);export default(e,t)=>d((()=>new Promise(((e,t)=>{const s=new i("/socket");s.addEventListener("open",(()=>{s.removeEventListener("error",t),e(s)}),o),s.addEventListener("error",t,o)})).then((s=>(y.reconnect(s),y.request("proxy",e).then((()=>t(g))).catch((e=>console.log(e))).finally((()=>y?.close())))))));